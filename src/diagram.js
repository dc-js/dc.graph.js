/**
 * `dc_graph.diagram` is a dc.js-compatible network visualization component. It registers in
 * the dc.js chart registry and its nodes and edges are generated from crossfilter groups. It
 * logically derives from the dc.js
 * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin},
 * but it does not physically derive from it since so much is different about network
 * visualization versus conventional charts.
 * @class diagram
 * @memberof dc_graph
 * @param {String|node} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector}
 * specifying a dom block element such as a div; or a dom element.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed
 * in. Filter interaction with a chart will only trigger events and redraws within the
 * chart's group.
 * @return {dc_graph.diagram}
 **/
dc_graph.diagram = function (parent, chartGroup) {
    // different enough from regular dc charts that we don't use dc.baseMixin
    // but attempt to implement most of that interface, copying some of the most basic stuff
    var _chart = dc.marginMixin({});
    _chart.__dcFlag__ = dc.utils.uniqueId();
    var _svg = null, _defs = null, _g = null, _nodeLayer = null, _edgeLayer = null, _splineLayer = null;
    var _dispatch = d3.dispatch('end', 'start', 'drawn', 'zoomed');
    var _nodes = {}, _edges = {}; // hold state between runs
    var _stats = {};
    var _nodes_snapshot, _edges_snapshot;
    var _children = {}, _arrows = {};
    var _running = false; // for detecting concurrency issues
    var _translate = [0,0], _scale = 1;
    var _zoom;
    var _anchor, _chartGroup;

    function deprecate_layout_algo_parameter(name) {
        return function(value) {
            if(!_chart.layoutEngine())
                _chart.layoutAlgorithm('cola', true);
            console.warn('Warning: dc_graph.diagram."' + name + '"is deprecated. Call the corresponding method on the layout engine instead.');
            var engine = _chart.layoutEngine();
            if(engine.getEngine)
                engine = engine.getEngine();
            engine[name](value);
            return this;
        };
    }

    /**
     * Set or get the width attribute of the diagram. See `.height` below.
     * @method width
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [width=200]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.width = property(200).react(function(w) {
        resizeSvg(w,0);
    });

    /**
     * Set or get the height attribute of the diagram. The width and height are applied to the
     * SVG element generated by the diagram when rendered. If a value is given, then the
     * diagram is returned for method chaining. If no value is given, then the current value of
     * the height attribute will be returned. Default: 200
     * @method height
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [height=200]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.height = property(200).react(function(h) {
        resizeSvg(0,h);
    });

    /**
     * Get or set the root element, which is usually the parent div. Normally the root is set
     * when the diagram is constructed; setting it later may have unexpected consequences.
     * @method root
     * @memberof dc_graph.diagram
     * @instance
     * @param {node} [root=null]
     * @return {node}
     * @return {dc_graph.diagram}
     **/
    _chart.root = property(null).react(function(e) {
        if(e.empty())
            console.log('Warning: parent selector ' + parent + " doesn't seem to exist");
    });

    /**
     * Get or set whether mouse wheel rotation or touchpad gestures will zoom the diagram, and
     * whether dragging on the background pans the diagram.
     * @method mouseZoomable
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [mouseZoomable=true]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.mouseZoomable = property(true);

    /**
     * Whether zooming should only be enabled when the alt key is pressed.
     * @method altKeyZoom
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [altKeyZoom=true]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.altKeyZoom = property(false);

    /**
     * Set or get the fitting strategy for the canvas, which affects how the
     * [viewBox](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox) and
     * [preserveAspectRatio](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio)
     * attributes get set. All options except `null` set the `viewBox` attribute.
     *
     * These options set the `viewBox` and adjust the scale and translate to implement the margins.
     * * `'default'` - uses the default behavior of `xMidYMid meet` (but with margins)
     * * `'vertical'` - fits the canvas vertically (with vertical margins) and centers it
     * horizontally. If the canvas is taller than the viewport, it will meet vertically and
     * there will be blank areas to the left and right. If the canvas is wider than the
     * viewport, it will be sliced.
     * * `'horizontal'` - fitst the canvas horizontally (with horizontal margins) and centers
     * it vertically. If the canvas is wider than the viewport, it will meet horizontally and
     * there will be blank areas above and below. If the canvas is taller than the viewport, it
     * will be sliced.
     *
     * Other options
     * * `null` - no attempt is made to fit the canvas to the svg element, `viewBox` is unset.
     * * another string - sets the `viewBox` and uses the string for `preserveAspectRatio`.
     * * function - will be called with (viewport width, viewport height, canvas width, canvas
     * height) and result will be used to set `preserveAspectRatio`.
     * @method fitStrategy
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [fitStrategy='default']
     * @return {String}
     * @return {dc_graph.diagram}
     **/
    _chart.fitStrategy = property('default');

    /**
     * Do not allow panning (scrolling) to push the diagram out of the viewable area, if there
     * is space for it to be shown. */
    _chart.restrictPan = property(false);

    /**
     * Auto-zoom behavior.
     * * `'always'` - zoom every time layout happens
     * * `'once'` - zoom the first time layout happens
     * * `null` - manual, call `zoomToFit` to fit
     * @method autoZoom
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [autoZoom=null]
     * @return {String}
     * @return {dc_graph.diagram}
     **/
    _chart.autoZoom = property(null);
    _chart.zoomToFit = function() {
        if(!(_nodeLayer && _edgeLayer))
            return;
        var node = _chart.selectAllNodes(),
            edge = _chart.selectAllEdges();
        auto_zoom(node, edge);
    };

    /**
     * Set or get the crossfilter dimension which represents the nodes (vertices) in the
     * diagram. Typically there will be a crossfilter instance for the nodes, and another for
     * the edges.

     * *The node dimension currently does nothing, but once selection is supported, it will be
     * used for filtering other charts on the same crossfilter instance based on the nodes
     * selected.*
     * @method nodeDimension
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.dimension} [nodeDimension]
     * @return {crossfilter.dimension}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeDimension = property();

    /**
     * Set or get the crossfilter group which is the data source for the nodes in the
     * diagram. The diagram will use the group's `.all()` method to get an array of `{key,
     * value}` pairs, where the key is a unique identifier, and the value is usually an object
     * containing the node's attributes. All accessors work with these key/value pairs.

     * If the group is changed or returns different values, the next call to `.redraw()` will
     * reflect the changes incrementally.

     * It is possible to pass another object with the same `.all()` interface instead of a
     * crossfilter group.
     * @method nodeGroup
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.group} [nodeGroup]
     * @return {crossfilter.group}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeGroup = property();

    /**
     * Set or get the crossfilter dimension which represents the edges in the
     * diagram. Typically there will be a crossfilter instance for the nodes, and another for
     * the edges.

     * *The edge dimension currently does nothing, but once selection is supported, it will be
     * used for filtering other charts on the same crossfilter instance based on the edges
     * selected.*

     * @method edgeDimension
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.dimension} [edgeDimension]
     * @return {crossfilter.dimension}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeDimension = property();

    /**
     * Set or get the crossfilter group which is the data source for the edges in the
     * diagram. See `.nodeGroup` above for the way data is loaded from a crossfilter group.

     * The values in the key/value pairs returned by `diagram.edgeGroup().all()` need to
     * support, at a minimum, the {@link dc_graph.diagram#nodeSource nodeSource} and
     * {@link dc_graph.diagram#nodeTarget nodeTarget}, which should return the same
     * keys as the {@link dc_graph.diagram#nodeKey nodeKey}

     * @method edgeGroup
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.group} [edgeGroup]
     * @return {crossfilter.group}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeGroup = property();

    /**
     * Set or get the function which will be used to retrieve the unique key for each node. By
     * default, this accesses the `key` field of the object passed to it. The keys should match
     * the keys returned by the {@link dc_graph.diagram#edgeSource edgeSource} and
     * {@link dc_graph.diagram#edgeTarget edgeTarget}.

     * @method nodeKey
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [nodeKey=function(kv) { return kv.key }]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeKey = _chart.nodeKeyAccessor = property(function(kv) {
        return kv.key;
    });

    /**
     * Set or get the function which will be used to retrieve the unique key for each edge. By
     * default, this accesses the `key` field of the object passed to it.

     * @method edgeKey
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeKey=function(kv) { return kv.key }]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeKey = _chart.edgeKeyAccessor = property(function(kv) {
        return kv.key;
    });

    /**
     * Set or get the function which will be used to retrieve the source (origin/tail) key of
     * the edge objects.  The key must equal the key returned by the `.nodeKey` for one of the
     * nodes; if it does not, or if the node is currently filtered out, the edge will not be
     * displayed. By default, looks for `.value.sourcename`.

     * @method edgeSource
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeSource=function(kv) { return kv.value.sourcename; }]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeSource = _chart.sourceAccessor = property(function(kv) {
        return kv.value.sourcename;
    });

    /**
     * Set or get the function which will be used to retrieve the target (destination/head) key
     * of the edge objects.  The key must equal the key returned by the
     * {@link dc_graph.diagram#nodeKey nodeKey} for one of the nodes; if it does not, or if the node
     * is currently filtered out, the edge will not be displayed. By default, looks for
     * `.value.targetname`.
     * @method edgeTarget
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeTarget=function(kv) { return kv.value.targetname; }]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeTarget = _chart.targetAccessor = property(function(kv) {
        return kv.value.targetname;
    });

    /**
     * Set or get the function which will be used to retrieve the radius, in pixels, for each
     * node. This determines the height of nodes,and if `nodeFitLabel` is false, the width too.
     * @method nodeRadius
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [nodeRadius=25]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeRadius = _chart.nodeRadiusAccessor = property(25);

    /**
     * Set or get the function which will be used to retrieve the stroke width, in pixels, for
     * drawing the outline of each node. According to the SVG specification, the outline will
     * be drawn half on top of the fill, and half outside. Default: 1
     * @method nodeStrokeWidth
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [nodeStrokeWidth=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeStrokeWidth = _chart.nodeStrokeWidthAccessor = property(1);

    /**
     * Set or get the function which will be used to retrieve the stroke color for the outline
     * of each node.
     * @method nodeStroke
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeStroke='black']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeStroke = _chart.nodeStrokeAccessor = property('black');

    /**
     * If set, the value returned from `nodeFill` will be processed through this
     * {@link https://github.com/mbostock/d3/wiki/Scales d3.scale}
     * to return the fill color. If falsy, uses the identity function (no scale).
     * @method nodeFillScale
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|d3.scale} [nodeFillScale]
     * @return {Function|d3.scale}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFillScale = property(null);

    /**
     * Set or get the function which will be used to retrieve the fill color for the body of each
     * node.
     * @method nodeFill
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeFill='white']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFill = _chart.nodeFillAccessor = property('white');

    /**
     * Set or get the function which will be used to retrieve the opacity of each node.
     * @method nodeOpacity
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [nodeOpacity=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeOpacity = property(1);

    /**
     * Set or get the padding or minimum distance, in pixels, for a node. (Will be distributed
     * to both sides of the node.)
     * @method nodePadding
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [nodePadding=6]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.nodePadding = property(6);

    /**
     * Set or get the function which will be used to retrieve the label text to display in each
     * node. By default, looks for a field `label` or `name` inside the `value` field.
     * @method nodeLabel
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeLabel]
     * @return {Function|String}
     * @example
     * // Default behavior
     * diagram.nodeLabel(function(kv) {
     *   return kv.value.label || kv.value.name;
     * });
     * @return {dc_graph.diagram}
     **/
    _chart.nodeLabel = _chart.nodeLabelAccessor = property(function(kv) {
        return kv.value.label || kv.value.name;
    });

    /**
     * Set or get the function which will be used to retrieve the label fill color. Default: null
     * @method nodeLabelFill
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeLabelFill=null]
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeLabelFill = _chart.nodeLabelFillAccessor = property(null);

    /**
     * Whether to fit the node shape around the label
     * @method nodeFitLabel
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Boolean} [nodeFitLabel=true]
     * @return {Function|Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFitLabel = _chart.nodeFitLabelAccessor = property(true);

    /**
     * The shape to use for drawing each node, specified as an object with at least the field
     * `shape`. The names of shapes are mostly taken
     * [from graphviz](http://www.graphviz.org/doc/info/shapes.html); currently ellipse, egg,
     * triangle, rectangle, diamond, trapezium, parallelogram, pentagon, hexagon, septagon, octagon,
     * invtriangle, invtrapezium, square, polygon are supported.
     *
     * If `shape = polygon`:
     * * `sides`: number of sides for a polygon
     * @method nodeShape
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Object} [nodeShape={shape: 'ellipse'}]
     * @return {Function|Object}
     * @return {dc_graph.diagram}
     * @example
     * // set shape to diamond or parallelogram based on flag
     * diagram.nodeShape(function(kv) {
     *   return {shape: kv.value.flag ? 'diamond' : 'parallelogram'};
     * });
     **/
    _chart.nodeShape = property(default_shape);

    /**
     * Set or get the function which will be used to retrieve the node title, usually rendered
     * as a tooltip. By default, uses the key of the node.
     * @method nodeTitle
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeTitle]
     * @return {Function|String}
     * @example
     * // Default behavior
     * chart.nodeTitle(function(kv) {
     *   return _chart.nodeKeyAccessor()(kv);
     * });
     * @return {dc_graph.diagram}
     **/
    _chart.nodeTitle = _chart.nodeTitleAccessor = property(function(kv) {
        return _chart.nodeKeyAccessor()(kv);
    });

    /**
     * By default, nodes are added to the layout in the order that `.nodeGroup().all()` returns
     * them. If specified, `.nodeOrdering` provides an accessor that returns a key to sort the
     * nodes on.  *It would be better not to rely on ordering to affect layout, but it may
     * affect the layout in some cases.*
     * @method nodeOrdering
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [nodeOrdering=null]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeOrdering = property(null);

    /**
     * Specify an accessor that returns an {x,y} coordinate for a node that should be
     * {@link https://github.com/tgdwyer/WebCola/wiki/Fixed-Node-Positions fixed in place},
     * and returns falsy for other nodes.
     * @method nodeFixed
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Object} [nodeFixed=null]
     * @return {Function|Object}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFixed = _chart.nodeFixedAccessor = property(null);


    /**
     * Set or get the function which will be used to retrieve the stroke color for the edges.
     * @method edgeStroke
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeStroke='black']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeStroke = _chart.edgeStrokeAccessor = property('black');

    /**
     * Set or get the function which will be used to retrieve the stroke width for the edges.
     * @method edgeStrokeWidth
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeStrokeWidth=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeStrokeWidth = _chart.edgeStrokeWidthAccessor = property(1);

    /**
     * Set or get the function which will be used to retrieve the edge opacity, a number from 0
     * to 1.
     * @method edgeOpacity
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeOpacity=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeOpacity = _chart.edgeOpacityAccessor = property(1);

    /**
     * Set or get the function which will be used to retrieve the edge label text. The label is
     * displayed when an edge is hovered over. By default, uses the `edgeKey`.
     * @method edgeLabel
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeLabel]
     * @example
     * // Default behavior
     * chart.edgeLabel(function(d) {
     *   return _chart.edgeKey()(d);
     * });
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeLabel = _chart.edgeLabelAccessor = property(function(d) {
        return _chart.edgeKey()(d);
    });

    /**
     * Set or get the function which will be used to retrieve the name of the arrowhead to use
     * for the target/ head/destination of the edge. Arrow symbols can be specified with
     * `.defineArrow()`. Return null to display no arrowhead.
     * @method edgeArrowhead
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeArrowhead='vee']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeArrowhead = _chart.edgeArrowheadAccessor = property('vee');

    /**
     * Set or get the function which will be used to retrieve the name of the arrow tail to use
     * for the tail/source of the edge. Arrow symbols can be specified with
     * `.defineArrow()`. Return null to display no arrowtail.
     * @method edgeArrowtail
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeArrowtail=null]
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeArrowtail = _chart.edgeArrowtailAccessor = property(null);

    /**
     * Multiplier for arrow size.
     * @method edgeArrowSize
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeArrowSize=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeArrowSize = property(1);

    /**
     * To draw an edge but not have it affect the layout, specify a function which returns
     * false for that edge.  By default, will return false if the `notLayout` field of the edge
     * value is truthy, true otherwise.
     * @method edgeIsLayout
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Boolean} [edgeIsLayout]
     * @example
     * // Default behavior
     * chart.edgeIsLayout(function(kv) {
     *   return !kv.value.notLayout;
     * });
     * @return {Function|Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeIsLayout = _chart.edgeIsLayoutAccessor = property(function(kv) {
        return !kv.value.notLayout;
    });

    // if false, don't draw or layout the edge. this is not documented because it seems like
    // the interface could be better and this combined with edgeIsLayout. (currently there is
    // no way to layout but not draw an edge.)
    _chart.edgeIsShown = property(true);

    /**
     * Currently, three strategies are supported for specifying the lengths of edges:
     * * 'individual' - uses the `edgeLength` for each edge. If it returns falsy, uses the
     * `baseLength`
     * * 'symmetric', 'jaccard' - compute the edge length based on the graph structure around
     * the edge. See
     * {@link https://github.com/tgdwyer/WebCola/wiki/link-lengths the cola.js wiki}
     * for more details.
     * 'none' - no edge lengths will be specified
     *
     * **Deprecated**: Use {@link dc_graph.cola_layout#lengthStrategy cola_layout.lengthStrategy} instead.
     * @method lengthStrategy
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [lengthStrategy='symmetric']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.lengthStrategy = deprecate_layout_algo_parameter('lengthStrategy');

    /**
     * When the `.lengthStrategy` is 'individual', this accessor will be used to read the
     * length of each edge.  By default, reads the `distance` field of the edge. If the
     * distance is falsy, uses the `baseLength`.
     * @method edgeLength
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeLength]
     * @example
     * // Default behavior
     * chart.edgeLength(function(kv) {
     *   return kv.value.distance;
     * });
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeLength = _chart.edgeDistanceAccessor = property(function(kv) {
        return kv.value.distance;
    });

    /**
     * This should be equivalent to rankdir and ranksep in the dagre/graphviz nomenclature, but for
     * now it is separate.
     *
     * **Deprecated**: use {@link dc_graph.cola_layout#flowLayout cola_layout.flowLayout} instead.
     * @method flowLayout
     * @memberof dc_graph.diagram
     * @instance
     * @param {Object} [flowLayout]
     * @example
     * // No flow (default)
     * chart.flowLayout(null)
     * // flow in x with min separation 200
     * chart.flowLayout({axis: 'x', minSeparation: 200})
     **/
    _chart.flowLayout = deprecate_layout_algo_parameter('flowLayout');

    /**
     * Direction to draw ranks. Currently for dagre and expand_collapse, but I think cola could be
     * generated from graphviz-style since it is more general.
     *
     * **Deprecated**: use {@link dc_graph.dagre_layout#rankdir dagre_layout.rankdir} instead.
     * @method rankdir
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [rankdir]
     **/
    _chart.rankdir = deprecate_layout_algo_parameter('rankdir');

    /**
     * Gets or sets the default edge length (in pixels) when the `.lengthStrategy` is
     * 'individual', and the base value to be multiplied for 'symmetric' and 'jaccard' edge
     * lengths.
     *
     * **Deprecated**: use {@link dc_graph.cola_layout#baseLength cola_layout.baseLength} instead.
     * @method baseLength
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [baseLength]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.baseLength = deprecate_layout_algo_parameter('baseLength');

    /**
     * Gets or sets the transition duration, the length of time each change to the diagram will
     * be animated.
     * @method transitionDuration
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [transitionDuration=500]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.transitionDuration = property(500);

    /**
     * How transitions should be split into separate animations to emphasize
     * the delete, modify, and insert operations:
     * * `none`: modify and insert operations animate at the same time
     * * `modins`: modify operations happen before inserts
     * * `insmod`: insert operations happen before modifies
     *
     * Deletions always happen before/during layout computation.
     * @method stageTransitions
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [stageTransitions='none']
     * @return {String}
     * @return {dc_graph.diagram}
     **/
    _chart.stageTransitions = property('none');

    /**
     * The delete transition happens simultaneously with layout, which can take longer
     * than the transition duration. Delaying it can bring it closer to the other
     * staged transitions.
     * @method deleteDelay
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [deleteDelay=0]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.deleteDelay = property(0);

    /**
     * Whether to put connected components each in their own group, to stabilize layout.
     * @method groupConnected
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [stageTransitions=false]
     * @return {String}
     * @return {dc_graph.diagram}
     **/
    _chart.groupConnected = property(false);

    /**
     * Gets or sets the maximum time spent doing layout for a render or redraw. Set to 0 for no
     * limit.
     * @method timeLimit
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [timeLimit=0]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.timeLimit = property(0);

    /**
     * Gets or sets a function which will be called with the current nodes and edges on each
     * redraw in order to derive new layout constraints. The constraints are built from scratch
     * on each redraw.

     * This can be used to generate alignment (rank) or axis constraints. By default, no
     * constraints will be added, although cola.js uses constraints internally to implement
     * flow and overlap prevention. See
     * {@link https://github.com/tgdwyer/WebCola/wiki/Constraints the cola.js wiki}
     * for more details.

     * For convenience, dc.graph.js implements a other constraints on top of those implemented
     * by cola.js:
     * * 'ordering' - the nodes will be ordered on the specified `axis` according to the keys
     * returned by the `ordering` function, by creating separation constraints using the
     * specified `gap`.
     * * 'circle' - (experimental) the nodes will be placed in a circle using "wheel"
     * edge lengths similar to those described in
     * {@link http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf Scalable, Versatile, and Simple Constrained Graph Layout}
     * *Although this is not as performant or stable as might be desired, it may work for
     * simple cases. In particular, it should use edge length *constraints*, which don't yet
     * exist in cola.js.*
     *
     * Because it is tedious to write code to generate constraints for a graph, **dc.graph.js**
     * also includes a {@link #dc_graph+constraint_pattern constraint generator} to produce
     * this constrain function, specifying the constraints themselves in a graph.
     * @method constrain
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [constrain]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.constrain = property(function(nodes, edges) {
        return [];
    });

    /**
     * If there are multiple edges between the same two nodes, start them this many pixels away
     * from the original so they don't overlap.
     * @method parallelEdgeOffset
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [parallelEdgeOffset=10]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.parallelEdgeOffset = property(10);

    /**
     * By default, edges are added to the layout in the order that `.edgeGroup().all()` returns
     * them. If specified, `.edgeOrdering` provides an accessor that returns a key to sort the
     * edges on.

     * *It would be better not to rely on ordering to affect layout, but it may affect the
     * layout in some cases. (Probably less than node ordering, but it does affect which
     * parallel edge is which.)*
     * @method edgeOrdering
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeOrdering=null]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeOrdering = property(null);

    _chart.cascade = function(level, add, props) {
        for(var p in props) {
            if(!_chart[p])
                throw new Error('unknown attribute ' + p);
            _chart[p].cascade(level, add ? props[p] : null);
        }
        return _chart;
    };

    /**
     * Currently there are some bugs when the same instance of cola.js is used multiple
     * times. (In particular, overlaps between nodes may not be eliminated
     * {@link https://github.com/tgdwyer/WebCola/issues/118 if cola is not reinitialized}
     * This flag can be set true to construct a new cola layout object on each redraw. However,
     * layout seems to be more stable if this is set false, so hopefully this will be fixed
     * soon.
     * @method initLayoutOnRedraw
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [initLayoutOnRedraw=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.initLayoutOnRedraw = property(false);

    /**
     * Whether to perform layout when the data is unchanged from the last redraw.
     * @method layoutUnchanged
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [layoutUnchanged=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.layoutUnchanged = property(false);

    /**
     * When `layoutUnchanged` is false, this will force layout to happen again. This may be needed
     * when changing a parameter but not changing the topology of the graph. (Yes, probably should
     * not be necessary.)
     * @method relayout
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.relayout = function() {
        _nodes_snapshot = _edges_snapshot = null;
        return this;
    };

    /**
     * Function to call to generate an initial layout. Takes (diagram, nodes, edges)
     *
     * **Deprecated**: The only layout that was using this was `tree_positions` and it never
     * worked as an initialization step for cola, as was originally intended. Now that
     * `tree_layout` is a layout algorithm, this should go away.
     *
     * In the future, there will be support for chaining layout algorithms. But that will be a
     * matter of composing them into a super-algorithm, not a special step like this was.
     * @method initialLayout
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [initialLayout=null]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.initialLayout = deprecated_property('initialLayout is deprecated - use layout algorithms instead', null);

    _chart.initialOnly = deprecated_property('initialOnly is deprecated - see the initialLayout deprecation notice in the documentation', false);

    /**
     * By default, all nodes are included, and edges are only included if both end-nodes are
     * visible.  If `.induceNodes` is set, then only nodes which have at least one edge will be
     * shown.
     * @method induceNodes
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [induceNodes=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.induceNodes = property(false);

    /**
     * If this flag is true, the positions of nodes and will be updated while layout is
     * iterating. If false, the positions will only be updated once layout has
     * stabilized. Note: this may not be compatible with transitionDuration.
     * @method showLayoutSteps
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [showLayoutSteps=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.showLayoutSteps = property(false);

    /**
     * Assigns a legend object which will be displayed within the same SVG element and
     * according to the visual encoding of this diagram.
     * @method legend
     * @memberof dc_graph.diagram
     * @instance
     * @param {Object} [legend=null]
     * @return {Object}
     * @return {dc_graph.diagram}
     **/
    _chart.legend = property(null).react(function(l) {
        l.parent(_chart);
    });

    /**
     * Specifies another kind of child layer or interface. For example, this can
     * be used to display tooltips on nodes using `dc_graph.tip`.

     * The child needs to support a `parent` method, the diagram to modify.
     * @method child
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [id] - the name of the child to modify or add
     * @param {Object} [object] - the child object to add, or null to remove
     * @example
     * // Display tooltips on node hover, via the d3-tip library
     * var tip = dc_graph.tip()
     * tip.content(function(d, k) {
     *   // you can do an asynchronous call here, e.g. d3.json, if you need
     *   // to fetch data to show the tooltip - just call k() with the content
     *   k("This is <em>" + d.orig.value.name + "</em>");
     * });
     * diagram.child('tip', tip);
     * @return {dc_graph.diagram}
     **/
    _chart.child = function(id, object) {
        if(arguments.length === 1)
            return _children[id];
        // do not notify unnecessarily
        if(_children[id] === object)
            return _chart;
        if(_children[id])
            _children[id].parent(null);
        _children[id] = object;
        if(object)
            object.parent(_chart);
        return _chart;
    };

    /**
     * Specify 'cola' (the default) or 'dagre' as the Layout Algorithm and it will replace the
     * back-end.
     *
     * **Deprecated**: use {@link dc_graph.diagram#layoutEngine diagram.layoutEngine} with the engine
     * object instead
     * @method layoutAlgorithm
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [algo='cola'] - the name of the layout algorithm to use
     * @example
     * // use dagre for layout
     * diagram.layoutAlgorithm('dagre');
     * @return {dc_graph.diagram}
     **/
    _chart.layoutAlgorithm = function(value, skipWarning) {
        if(!arguments.length)
            return _chart.layoutEngine() ? _chart.layoutEngine().layoutAlgorithm() : 'cola';
        if(!skipWarning)
            console.warn('dc.graph.diagram.layoutAlgorithm is depecrated - pass the layout engine object to dc_graph.diagram.layoutEngine instead');

        var engine;
        switch(value) {
        case 'cola':
            engine = dc_graph.cola_layout();
            break;
        case 'dagre':
            engine = dc_graph.dagre_layout();
        }
        engine = dc_graph.webworker_layout(engine);
        _chart.layoutEngine(engine);
        return this;
    };

    /**
     * The layout engine determines how to draw things!
     * @method layoutEngine
     * @memberof dc_graph.diagram
     * @instance
     * @param {Object} [engine=null] - the layout engine to use
     * @example
     * // use cola with no webworker
     * diagram.layoutEngine(dc_graph.cola_layout());
     * // use dagre with a webworker
     * diagram.layoutEngine(dc_graph.webworker_layout(dc_graph.dagre_layout()));
     **/
    _chart.layoutEngine = property(null).react(function(val) {
        if(val && val.parent)
            val.parent(_chart);
    });

    _chart.tickSize = deprecate_layout_algo_parameter('tickSize');


    _chart.uniqueId = function() {
        return _chart.anchorName().replace(/[ .#=\[\]"]/g, '-');
    };

    _chart.edgeId = function(d) {
        return 'edge-' + _chart.edgeKey.eval(d).replace(/[^\w-_]/g, '-');
    };

    _chart.arrowId = function(d, kind) {
        return 'arrow-' + kind + '-' + _chart.uniqueId() + '-'  + _chart.edgeId(d);
    };
    _chart.textpathId = function(d) {
        return 'textpath-' + _chart.uniqueId() + '-' + _chart.edgeId(d);
    };

    // this kind of begs a (meta)graph ADT
    // instead of munging this into the diagram
    _chart.getNode = function(id) {
        return _nodes[id] ? _nodes[id].orig : null;
    };

    _chart.getNodeAllInfo = function(id) {
        return _nodes[id] ? _nodes[id] : null;
    };

    /**
     * Instructs cola.js to fit the connected components.
     *
     * **Deprecated**: Use
     * {@link dc_graph.cola_layout#handleDisconnected cola_layout.handleDisconnected} instead.
     * @method handleDisconnected
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [handleDisconnected=true]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.handleDisconnected = deprecate_layout_algo_parameter('handleDisconnected');

    function initLayout() {
        if(!_chart.layoutEngine())
            _chart.layoutAlgorithm('cola', true);
        _chart.layoutEngine().init({
            width: _chart.width(),
            height: _chart.height()
        });
    }

    _chart._enterNode = function(nodeEnter) {
        if(_chart.nodeTitle())
            nodeEnter.append('title');
        nodeEnter.each(infer_shape(_chart));
        nodeEnter.append(shape_element(_chart))
            .attr('class', 'node-shape');
        nodeEnter.append('text')
            .attr('class', 'node-label');
        return _chart;
    };

    _chart._updateNode = function(node) {
        var changedShape = node.filter(shape_changed(_chart));
        changedShape.select('.node-shape').remove();
        changedShape.each(infer_shape(_chart));
        changedShape.insert(shape_element(_chart), ':first-child')
            .attr('class', 'node-shape');
        node.select('title')
            .text(_chart.nodeTitle.eval);
        var text = node.select('text.node-label');
        var tspan = text.selectAll('tspan').data(function(n) {
            var lines = _chart.nodeLabel.eval(n);
            if(!lines)
                return [];
            else if(typeof lines === 'string')
                lines = [lines];
            var first = lines.length%2 ? 0.3 - (lines.length-1)/2 : 1-lines.length/2;
            return lines.map(function(line, i) { return {line: line, ofs: (i==0 ? first : 1) + 'em'}; });
        });
        tspan.enter().append('tspan')
            .attr('x', 0)
            .attr('dy', function(d) { return d.ofs; });
        tspan.text(function(d) { return d.line; });
        tspan.exit().remove();
        text
            .attr('fill', _chart.nodeLabelFill.eval)
            .each(fit_shape(_chart));
        node.select('.node-shape')
            .each(shape_attrs(_chart))
            .attr({
                stroke: _chart.nodeStroke.eval,
                'stroke-width': _chart.nodeStrokeWidth.eval,
                fill: compose(_chart.nodeFillScale() || identity, _chart.nodeFill.eval)
            });
        return _chart;
    };

    function has_source_and_target(e) {
        return !!e.source && !!e.target;
    }

    // three stages: delete before layout, and modify & insert split the transitionDuration
    function transition_duration() {
        return (_chart.stageTransitions() !== 'none') ?
            _chart.transitionDuration() / 2 :
            _chart.transitionDuration();
    }

    function transition_delay(is_enter) {
        return _chart.stageTransitions() === 'none' ||
            _chart.stageTransitions() === 'modins' === !is_enter ?
            0 :
            _chart.transitionDuration() / 2;
    }

    _chart.selectAllNodes = function(selector) {
        selector = selector || '.node';
        return _nodeLayer.selectAll(selector).filter(function(d) {
            return !d.deleted;
        });
    };

    _chart.selectAllEdges = function(selector) {
        selector = selector || '.edge';
        return _edgeLayer.selectAll(selector).filter(function(d) {
            return !d.deleted;
        });
    };

    _chart.selectAllDefs = function(selector) {
        return _defs.selectAll(selector).filter(function(d) {
            return !d.deleted;
        });
    };

    _chart.isRunning = function() {
        return _running;
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Computes a new layout based on the nodes and edges in the edge groups, and
     * displays the diagram.  To the extent possible, the diagram will minimize changes in
     * positions from the previous layout.  `.render()` must be called the first time, and
     * `.redraw()` can be called after that.

     * `.redraw()` will be triggered by changes to the filters in any other charts in the same
     * dc.js chart group.

     * Unlike in dc.js, `redraw` executes asynchronously, because drawing can be computationally
     * intensive, and the diagram will be drawn multiple times if
     * {@link #dc_graph.diagram+showLayoutSteps showLayoutSteps}
     * is enabled. Watch the {@link #dc_graph.diagram+on 'end'} event to know when layout is
     * complete.
     **/
    var _needsRedraw = false;
    _chart.redraw = function () {
        // since dc.js can receive UI events and trigger redraws whenever it wants,
        // and cola absolutely will not tolerate being poked while it's doing layout,
        // we need to guard the startLayout call.
        if(_running) {
            _needsRedraw = true;
            return this;
        }
        else return _chart.startLayout();
    };

    _chart.startLayout = function () {
        var nodes = _chart.nodeGroup().all();
        var edges = _chart.edgeGroup().all();
        if(_running) {
            throw new Error('dc_graph.diagram.redraw already running!');
        }
        _running = true;

        _chart.layoutEngine().stop();

        if(_chart.initLayoutOnRedraw())
            initLayout();

        // ordering shouldn't matter, but we support ordering in case it does
        if(_chart.nodeOrdering()) {
            nodes = crossfilter.quicksort.by(_chart.nodeOrdering())(nodes.slice(0), 0, nodes.length);
        }
        if(_chart.edgeOrdering()) {
            edges = crossfilter.quicksort.by(_chart.edgeOrdering())(edges.slice(0), 0, edges.length);
        }

        var wnodes = regenerate_objects(_nodes, nodes, function(v) {
            return _chart.nodeKey()(v);
        }, function(v1, v) {
            v1.orig = v;
            v1.cola = v1.cola || {};
            v1.cola.dcg_nodeKey = _chart.nodeKey.eval(v1);
            if(_chart.nodeFixed())
                v1.cola.dcg_nodeFixed = _chart.nodeFixed.eval(v1);
            _chart.layoutEngine().populateLayoutNode(v1.cola, v1);
        });
        var wedges = regenerate_objects(_edges, edges, function(e) {
            return _chart.edgeKey()(e);
        }, function(e1, e) {
            e1.orig = e;
            e1.cola = e1.cola || {};
            e1.cola.dcg_edgeKey = _chart.edgeKey.eval(e1);
            e1.cola.dcg_edgeSource = _chart.edgeSource.eval(e1);
            e1.cola.dcg_edgeTarget = _chart.edgeTarget.eval(e1);
            e1.source = _nodes[e1.cola.dcg_edgeSource];
            e1.target = _nodes[e1.cola.dcg_edgeTarget];
            e1.cola.dcg_edgeLength = _chart.edgeLength.eval(e1);
            _chart.layoutEngine().populateLayoutEdge(e1.cola, e1);
        });

        // remove edges that don't have both end nodes
        wedges = wedges.filter(has_source_and_target);

        // remove self-edges (since we can't draw them - will be option later)
        wedges = wedges.filter(function(e) { return e.source !== e.target; });

        wedges = wedges.filter(_chart.edgeIsShown.eval);

        // and optionally, nodes that have no edges
        if(_chart.induceNodes()) {
            var keeps = {};
            wedges.forEach(function(e) {
                keeps[e.cola.dcg_edgeSource] = true;
                keeps[e.cola.dcg_edgeTarget] = true;
            });
            wnodes = wnodes.filter(function(n) { return keeps[n.cola.dcg_nodeKey]; });
            for(var k in _nodes)
                if(!keeps[k])
                    delete _nodes[k];
        }

        wnodes.forEach(function(v, i) {
            v.index = i;
        });

        _stats = {nnodes: wnodes.length, nedges: wedges.length};

        // annotate parallel edges so we can draw them specially
        if(_chart.parallelEdgeOffset()) {
            var em = new Array(wnodes.length);
            for(var i = 0; i < em.length; ++i) {
                em[i] = new Array(em.length); // technically could be diagonal array
                for(var j = 0; j < em.length; ++j)
                    em[i][j] = {
                        n: 0,
                        ports: {
                            rev: []
                        }
                    };
            }
            wedges.forEach(function(e) {
                var min = Math.min(e.source.index, e.target.index),
                    max = Math.max(e.source.index, e.target.index);
                e.parallel = em[min][max].n++;
                e.ports = em[min][max].ports;
                e.ports.rev.push(min !== e.source.index);
            });
            for(i = 0; i < em.length; ++i)
                for(j = 0; j < em.length; ++j)
                    if(em[i][j].n)
                        em[i][j].ports.n = em[i][j].n;
        }

        // create edge SVG elements
        var edge = _edgeLayer.selectAll('.edge')
                .data(wedges, _chart.edgeKey.eval);
        var edgeEnter = edge.enter().append('svg:path')
                .attr({
                    class: 'edge',
                    id: _chart.edgeId,
                    opacity: 0
                });

        edge.exit().each(function(d) {
            d.deleted = true;
        }).transition()
            .duration(transition_duration())
            .delay(_chart.deleteDelay())
            .attr('opacity', 0)
            .each(function(d) {
                edgeArrow(d, 'head', null);
                edgeArrow(d, 'head', null);
            })
            .remove();

        // another wider copy of the edge just for hover events
        var edgeHover = _edgeLayer.selectAll('.edge-hover')
                .data(wedges, _chart.edgeKey.eval);
        var edgeHoverEnter = edgeHover.enter().append('svg:path')
            .attr('class', 'edge-hover')
            .attr('opacity', 0)
            .attr('stroke', 'green')
            .attr('stroke-width', 10)
            .on('mouseover', function(d) {
                d3.select('#' + _chart.edgeId(d) + '-label')
                    .attr('visibility', 'visible');
            })
            .on('mouseout', function(d) {
                d3.select('#' + _chart.edgeId(d) + '-label')
                    .attr('visibility', 'hidden');
            });
        edgeHover.exit().remove();

        var edgeLabels = _edgeLayer.selectAll('.edge-label')
                .data(wedges, _chart.edgeKey.eval);
        var edgeLabelsEnter = edgeLabels.enter()
              .append('text')
                .attr('id', function(d) {
                    return _chart.edgeId(d) + '-label';
                })
                .attr('visibility', 'hidden')
                .attr({'class':'edge-label',
                       'text-anchor': 'middle',
                       dy:-2})
              .append('textPath')
                .attr('startOffset', '50%')
                .attr('xlink:href', function(d) {
                    var id = _chart.textpathId(d);
                    return '#' + id;
                });
        var textPaths = _defs.selectAll('path.edge-label-path')
                .data(wedges, _chart.textpathId);
        var textPathsEnter = textPaths.enter()
                .append('svg:path').attr({
                    class: 'edge-label-path',
                    id: _chart.textpathId
                });
        edgeLabels
          .selectAll('textPath')
            .text(function(d){
                return _chart.edgeLabel.eval(d);
            });
        edgeLabels.exit().transition()
            .duration(transition_duration())
            .delay(_chart.deleteDelay())
            .attr('opacity', 0).remove();

        // create node SVG elements
        var node = _nodeLayer.selectAll('.node')
                .data(wnodes, _chart.nodeKey.eval);
        var nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr('opacity', '0'); // don't show until has layout
        // .call(_d3cola.drag);

        _chart._enterNode(nodeEnter);

        node.exit().each(function(d) {
            d.deleted = true;
        }).transition()
            .duration(transition_duration())
            .delay(_chart.deleteDelay())
            .attr('opacity', 0)
            .remove();

        _dispatch.drawn(node, edge, edgeHover);

        _refresh(node, edge);

        // really we should have layout chaining like in the good old Dynagraph days
        // the ordering of this and the previous 4 statements is somewhat questionable
        if(_chart.initialLayout())
            _chart.initialLayout()(_chart, wnodes, wedges);

        // no layout if the topology hasn't changed
        var skip_layout = false;
        if(!_chart.layoutUnchanged()) {
            var nodes_snapshot = JSON.stringify(wnodes.map(get_original)),
                edges_snapshot = JSON.stringify(wedges.map(get_original));
            if(nodes_snapshot === _nodes_snapshot && edges_snapshot === _edges_snapshot)
                skip_layout = true;
            _nodes_snapshot = nodes_snapshot;
            _edges_snapshot = edges_snapshot;
        }

        // cola constraints always use indices, but node references
        // are more friendly, so translate those

        // i am not satisfied with this constraint generation api...
        // https://github.com/dc-js/dc.graph.js/issues/10
        var constraints = _chart.constrain()(_chart, wnodes, wedges);
        // translate references from names to indices (ugly)
        constraints.forEach(function(c) {
            if(c.type) {
                switch(c.type) {
                case 'alignment':
                    c.offsets.forEach(function(o) {
                        o.node = _nodes[o.node].index;
                    });
                    break;
                case 'circle':
                    c.nodes.forEach(function(n) {
                        n.node = _nodes[n.node].index;
                    });
                    break;
                }
            } else if(c.axis) {
                c.left = _nodes[c.left].index;
                c.right = _nodes[c.right].index;
            }
        });

        // pseudo-cola.js features

        // 1. non-layout edges are drawn but not told to cola.js
        var layout_edges = wedges.filter(_chart.edgeIsLayout.eval);
        var nonlayout_edges = wedges.filter(function(x) {
            return !_chart.edgeIsLayout.eval(x);
        });

        // 2. type=circle constraints
        var circle_constraints = constraints.filter(function(c) {
            return c.type === 'circle';
        });
        constraints = constraints.filter(function(c) {
            return c.type !== 'circle';
        });
        circle_constraints.forEach(function(c) {
            var R = (c.distance || _chart.baseLength()*4) / (2*Math.sin(Math.PI/c.nodes.length));
            var nindices = c.nodes.map(function(x) { return x.node; });
            var namef = function(i) {
                return _chart.nodeKey.eval(wnodes[i]);
            };
            var wheel = dc_graph.wheel_edges(namef, nindices, R)
                    .map(function(e) {
                        var e1 = {internal: e};
                        e1.source = _nodes[e.sourcename];
                        e1.target = _nodes[e.targetname];
                        return e1;
                    });
            layout_edges = layout_edges.concat(wheel);
        });

        // 3. ordered alignment
        var ordered_constraints = constraints.filter(function(c) {
            return c.type === 'ordering';
        });
        constraints = constraints.filter(function(c) {
            return c.type !== 'ordering';
        });
        ordered_constraints.forEach(function(c) {
            var sorted = c.nodes.map(function(n) { return _nodes[n]; });
            if(c.ordering) {
                var sort = crossfilter.quicksort.by(param(c.ordering));
                sorted = sort(sorted, 0, sorted.length);
            }
            var left;
            sorted.forEach(function(n, i) {
                if(i===0)
                    left = n;
                else {
                    constraints.push({
                        left: left.index,
                        right: (left = n).index,
                        axis: c.axis,
                        gap: c.gap
                    });
                }
            });
        });
        if(_chart.legend())
            _chart.legend().redraw();
        if(skip_layout) {
            _running = false;
            _dispatch.end(false);
            return this;
        }
        var startTime = Date.now();

        function populate_cola(rnodes, redges) {
            rnodes.forEach(function(rn) {
                var n = _nodes[rn.dcg_nodeKey];
                if(!n) {
                    console.warn('received node "' + rn.dcg_nodeKey + '" that we did not send');
                    return;
                }
                n.cola.x = rn.x;
                n.cola.y = rn.y;
            });
            redges.forEach(function(re) {
                var e = _edges[re.dcg_edgeKey];
                if(!e) {
                    console.warn('received edge "' + re.dcg_edgeKey + '" that we did not send');
                    return;
                }
            });
        }
        _chart.layoutEngine()
            .on('tick', function(nodes, edges) {
                var elapsed = Date.now() - startTime;
                if(!_chart.initialOnly())
                    populate_cola(nodes, edges);
                if(_chart.showLayoutSteps())
                    draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter, textPaths, textPathsEnter);
                if(_needsRedraw || _chart.timeLimit() && elapsed > _chart.timeLimit()) {
                    console.log('cancelled');
                    _chart.layoutEngine().stop();
                }
            })
            .on('end', function(nodes, edges) {
                if(!_chart.showLayoutSteps()) {
                    if(!_chart.initialOnly())
                        populate_cola(nodes, edges);
                    draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter, textPaths, textPathsEnter);
                }
                else layout_done(true);
                var do_zoom;
                switch(_chart.autoZoom()) {
                case 'always':
                    do_zoom = true;
                    break;
                case 'once':
                    do_zoom = true;
                    _chart.autoZoom(null);
                    break;
                default:
                    do_zoom = false;
                }
                calc_bounds(node, edge);
                if(do_zoom)
                    auto_zoom();
            })
            .on('start', function() {
                console.log('algo ' + _chart.layoutEngine().layoutAlgorithm() + ' started.');
                _dispatch.start();
            });

        if(_chart.initialOnly())
            _chart.layoutEngine().dispatch().end(wnodes, wedges);
        else {
            _dispatch.start(); // cola doesn't seem to fire this itself?
            _chart.layoutEngine().data(
                wnodes.map(function(v) { return v.cola; }),
                layout_edges.map(function(v) { return v.cola; }),
                constraints,
                {groupConnected: _chart.groupConnected()}
            );
            _chart.layoutEngine().start({
                initialUnconstrainedIterations: 10,
                initialUserConstraintIterations: 20,
                initialAllConstraintsIterations: 20
            });
        }
        return this;
    };

    function _refresh(node, edge) {
        edge
            .attr('stroke', _chart.edgeStroke.eval)
            .attr('stroke-width', _chart.edgeStrokeWidth.eval)
            .attr('marker-end', function(d) {
                var name = _chart.edgeArrowhead.eval(d),
                    id = edgeArrow(d, 'head', name);
                return id ? 'url(#' + id + ')' : null;
            })
            .attr('marker-start', function(d) {
                var name = _chart.edgeArrowtail.eval(d),
                    arrow_id = edgeArrow(d, 'tail', name);
                return name ? 'url(#' + arrow_id + ')' : null;
            })
            .each(function(e) {
                d3.selectAll('#' + _chart.arrowId(e, 'head') + ',#' + _chart.arrowId(e, 'tail'))
                    .attr('fill', _chart.edgeStroke.eval(e));
            });

        _chart._updateNode(node);
    }

    _chart.refresh = function(node, edge, edgeHover, edgeLabels, textPaths) {
        node = node || _chart.selectAllNodes();
        edge = edge || _chart.selectAllEdges();
        _refresh(node, edge);

        edgeHover = edgeHover || _chart.selectAllEdges('.edge-hover');
        edgeLabels = edgeLabels || _chart.selectAllEdges('.edge-label');
        textPaths = textPaths || _chart.selectAllDefs('path.edge-label-path');
        var nullSel = d3.select(null); // no enters
        draw(node, nullSel, edge, nullSel, edgeHover, nullSel, edgeLabels, nullSel, textPaths, nullSel);
    };


    function layout_done(happens) {
        _dispatch.end(happens);
        _running = false;
        if(_needsRedraw) {
            _needsRedraw = false;
            window.setTimeout(function() {
                if(!_chart.isRunning()) // someone else may already have started
                    _chart.redraw();
            }, 0);
        }
    }

    function calc_edge_path(d, age, sx, sy, tx, ty) {
        if(!d.ports[age]) {
            var source_padding = d.source.dcg_ry +
                    _chart.nodeStrokeWidth.eval(d.source) / 2,
                target_padding = d.target.dcg_ry +
                    _chart.nodeStrokeWidth.eval(d.target) / 2;
            d.ports[age] = new Array(d.ports.n);
            var reversedness = d.ports.rev[d.parallel];
            for(var p = 0; p < d.ports.n; ++p) {
                // alternate parallel edges over, then under
                var dir = (!!(p%2) === (sx < tx)) ? -1 : 1,
                    port = Math.floor((p+1)/2),
                    last = port ? d.ports[age][p > 2 ? p - 2 : 0].path : null;
                var path = draw_edge_to_shapes(_chart, d.source, d.target, sx, sy, tx, ty,
                                              last, dir, _chart.parallelEdgeOffset(),
                                              source_padding, target_padding
                                              );
                if(d.ports.rev[p] !== reversedness)
                    path.points.reverse();
                var spos = path.points[0], tpos = path.points[path.points.length-1];
                var near = bezier_point(path.points, 0.75);
                d.ports[age][p] = {
                    path: path,
                    orient: Math.atan2(tpos.y - near.y, tpos.x - near.x) + 'rad'
                };
            }
        }
        return d.ports[age][d.parallel].path;
    }

    function calc_old_edge_path(d) {
        calc_edge_path(d, 'old', d.source.prevX || d.source.cola.x, d.source.prevY || d.source.cola.y,
                         d.target.prevX || d.target.cola.x, d.target.prevY || d.target.cola.y);
    }

    function calc_new_edge_path(d) {
        var path = calc_edge_path(d, 'new', d.source.cola.x, d.source.cola.y, d.target.cola.x, d.target.cola.y);
        var spos = path.points[0], tpos = path.points[path.points.length-1];
        d.length = Math.hypot(tpos.x-spos.x, tpos.y-spos.y);
    }

    function render_edge_path(age) {
        return function(d) {
            var path = d.ports[age][d.parallel].path;
            return generate_path(path.points, path.bezDegree);
        };
    }

    function render_edge_label_path(age) {
        return function(d) {
            var path = d.ports[age][d.parallel].path;
            var points = d.target.cola.x < d.source.cola.x ?
                    path.points.slice(0).reverse() : path.points;
            return generate_path(points, path.bezDegree);
        };
    }

    // wait on multiple transitions, adapted from
    // http://stackoverflow.com/questions/10692100/invoke-a-callback-at-the-end-of-a-transition
    function endall(transitions, callback) {
        if (transitions.every(function(transition) { return transition.size() === 0; }))
            callback();
        var n = 0;
        transitions.forEach(function(transition) {
            transition
                .each(function() { ++n; })
                .each('end.all', function() { if (!--n) callback(); });
        });
    }

    function node_bounds(n) {
        return {left: n.cola.x - n.dcg_rx, top: n.cola.y - n.dcg_ry,
                right: n.cola.x + n.dcg_rx, bottom: n.cola.y + n.dcg_ry};
    }

    function union_bounds(b1, b2) {
        return {
            left: Math.min(b1.left, b2.left),
            top: Math.min(b1.top, b2.top),
            right: Math.max(b1.right, b2.right),
            bottom: Math.max(b1.bottom, b2.bottom)
        };
    }

    function point_to_bounds(p) {
        return {
            left: p.x,
            top: p.y,
            right: p.x,
            bottom: p.y
        };
    }

    function edge_bounds(e) {
        // assumption: edge must have some points
        var points = e.ports.new[e.parallel].path.points;
        return points.map(point_to_bounds).reduce(union_bounds);
    }

    function debug_bounds(bounds) {
        var brect = _g.selectAll('rect.bounds').data([0]);
        brect.enter()
            .insert('rect', ':first-child').attr({
                class: 'bounds',
                fill: 'rgba(128,255,128,0.1)',
                stroke: '#000'
            });
        brect
            .attr({
                x: bounds.left,
                y: bounds.top,
                width: bounds.right - bounds.left,
                height: bounds.bottom - bounds.top
            });
    }

    var _bounds;
    function calc_bounds(node, edge) {
        if((_chart.fitStrategy() || _chart.restrictPan()) && node.size()) {
            // assumption: there can be no edges without nodes
            _bounds = node.data().map(node_bounds).reduce(union_bounds);
            _bounds = edge.data().map(edge_bounds).reduce(union_bounds, _bounds);
        }
    }

    function auto_zoom() {
        if(_chart.fitStrategy()) {
            if(!_bounds)
                return;
            var vwidth = _bounds.right - _bounds.left, vheight = _bounds.bottom - _bounds.top,
                swidth =  _chart.width(), sheight = _chart.height(), viewBox;
            if(_chart.DEBUG_BOUNDS)
                debug_bounds(_bounds);
            var fitS = _chart.fitStrategy(), pAR, translate = [0,0], scale = 1,
                amv; // align margins vertically
            if(['default', 'vertical', 'horizontal'].indexOf(fitS) >= 0) {
                var sAR = sheight / swidth, vAR = vheight / vwidth,
                    vrl = vAR<sAR; // view aspect ratio is less (wider)
                if(fitS === 'default') {
                    amv = !vrl;
                    pAR = null;
                }
                else {
                    amv = fitS==='vertical';
                    pAR = 'xMidYMid ' + (vrl ^ amv ? 'meet' : 'slice');
                }
                translate = [_chart.margins().left, _chart.margins().top];
                scale = amv ?
                    (sheight - _chart.margins().top - _chart.margins().bottom) / sheight :
                    (swidth - _chart.margins().left - _chart.margins().right) / swidth;
            }
            else if(typeof fitS === 'string' && fitS.match(/^align_/)) {
                var sides = fitS.split('_')[1].toLowerCase().split('');
                if(sides.length > 2)
                    throw new Error("align_ expecting 0-2 sides, not " + sides.length);
                var bounds = margined_bounds();
                translate = _zoom.translate();
                scale = _zoom.scale();
                sides.forEach(function(s) {
                    switch(s) {
                    case 'l':
                        translate[0] = align_left(translate, bounds.left);
                        break;
                    case 't':
                        translate[1] = align_top(translate, bounds.top);
                        break;
                    case 'r':
                        translate[0] = align_right(translate, bounds.right);
                        break;
                    case 'b':
                        translate[1] = align_bottom(translate, bounds.bottom);
                        break;
                    default:
                        throw new Error("align_ expecting l t r or b, not '" + s + "'");
                    }
                });
            }
            else if(typeof fitS === 'function') {
                var fit = fitS(vwidth, vheight, swidth, sheight);
                pAR = fit.pAR;
                translate = fit.translate;
                scale = fit.scale;
                viewBox = fit.viewBox;
            }
            else if(typeof fitS === 'string')
                pAR = _chart.fitStrategy();
            else
                throw new Error('unknown fitStrategy type ' + typeof fitS);

            if(pAR !== undefined) {
                if(!viewBox)
                    viewBox = [_bounds.left, _bounds.top, vwidth, vheight].join(' ');
                _svg.attr({
                    viewBox: viewBox,
                    preserveAspectRatio: pAR
                });
            }
            _zoom.translate(translate).scale(scale).event(_svg);
            _dispatch.zoomed(translate, scale);
        }
    }

    function draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter, textPaths, textPathsEnter) {
        console.assert(edge.data().every(has_source_and_target));

        var nodeEntered = {};
        nodeEnter
            .each(function(n) {
                nodeEntered[_chart.nodeKey.eval(n)] = true;
            })
            .attr('transform', function (d) {
                // start new nodes at their final position
                return 'translate(' + d.cola.x + ',' + d.cola.y + ')';
            });
        var ntrans = node
                .transition()
                .duration(transition_duration())
                .delay(function(n) {
                    return transition_delay(nodeEntered[_chart.nodeKey.eval(n)]);
                })
                .attr('opacity', _chart.nodeOpacity.eval)
                .attr('transform', function (d) {
                    return 'translate(' + d.cola.x + ',' + d.cola.y + ')';
                })
                .each('end.record', function(d) {
                    d.prevX = d.cola.x;
                    d.prevY = d.cola.y;
                });

        // reset edge ports
        edge.each(function(d) {
            d.ports.new = null;
            d.ports.old = null;
        });

        var edgeEntered = {};
        edgeEnter
            .each(function(e) {
                edgeEntered[_chart.edgeKey.eval(e)] = true;
            })
            .each(function(e) {
                // if staging transitions, just fade new edges in at new position
                // else start new edges at old positions of nodes, if any, else new positions
                var age;
                if(_chart.stageTransitions() === 'modins') {
                    calc_new_edge_path(e);
                    age = 'new';
                }
                else {
                    calc_old_edge_path(e);
                    age = 'old';
                }
                if(_chart.edgeArrowhead.eval(e))
                    d3.select('#' + _chart.arrowId(e, 'head'))
                    .attr('orient', function() {
                        return e.ports[age][e.parallel].orient;
                    });
            })
            .attr('d', render_edge_path(_chart.stageTransitions() === 'modins' ? 'new' : 'old'));

        var etrans = edge.each(calc_new_edge_path)
                .each(function(e) {
                    if(_chart.edgeArrowhead.eval(e)) {
                        d3.select('#' + _chart.arrowId(e, 'head'))
                            .transition().duration(transition_duration())
                            .delay(transition_delay(false))
                            .attr('orient', function() {
                                return e.ports.new[e.parallel].orient;
                            });
                    }
                })
              .transition()
                .duration(transition_duration())
                .delay(function(e) {
                    return transition_delay(edgeEntered[_chart.edgeKey.eval(e)]);
                })
                .attr('opacity', _chart.edgeOpacity.eval)
                .attr('d', function(e) {
                    var when = _chart.stageTransitions() === 'insmod' &&
                            edgeEntered[_chart.edgeKey.eval(e)] ? 'old' : 'new';
                    return render_edge_path(when)(e);
                });
        textPathsEnter
            .attr('d', render_edge_label_path(_chart.stageTransitions() === 'modins' ? 'new' : 'old'));
        var textTrans = textPaths.transition()
            .duration(transition_duration())
            .delay(function(e) {
                return transition_delay(edgeEntered[_chart.edgeKey.eval(e)]);
            })
            .attr('opacity', _chart.edgeOpacity.eval)
            .attr('d', function(e) {
                var when = _chart.stageTransitions() === 'insmod' &&
                        edgeEntered[_chart.edgeKey.eval(e)] ? 'old' : 'new';
                return render_edge_label_path(when)(e);
            });
        if(_chart.stageTransitions() === 'insmod') {
            // inserted edges transition twice in insmod mode
            if(transition_duration() >= 50) {
                etrans = etrans.transition()
                    .duration(transition_duration())
                    .attr('d', render_edge_path('new'));
                textTrans = textTrans.transition()
                    .duration(transition_duration())
                    .attr('d', render_edge_label_path('new'));
            } else {
                // if transitions are too short, we run into various problems,
                // from transitions not completing to objects not found
                // so don't try to chain in that case
                // this also helped once: d3.timer.flush();
                etrans
                    .attr('d', render_edge_path('new'));
                textTrans
                    .attr('d', render_edge_path('new'));
            }
        }

        // signal layout done when all transitions complete
        // because otherwise client might start another layout and lock the processor
        if(!_chart.showLayoutSteps())
            endall([ntrans, etrans, textTrans], function() { layout_done(true); });

        edgeHover.attr('d', render_edge_path('new'));
    }

    // draw the spline for paths
    _chart.drawSpline = function (paths, pathprops) {
        var _getNodePosition = function(path) {
            var plist = [];
            for(var i = 0; i < path.element_list.length; i ++) {
                var uid = path.element_list[i].property_map.ecomp_uid;
                var node = _chart.getNodeAllInfo(uid);
                if(node !== null) {
                    plist.push({'x': node.cola.x, 'y': node.cola.y});
                }
            }
            return plist;
        };

        var _drawSpline = function(path, i, array) {
            var plist = _getNodePosition(path);
            if(plist.length > 0) {

                var line = d3.svg.line()
                    .interpolate("cardinal")
                    .x(function(d) { return d.x; })
                    .y(function(d) { return d.y; });

                _splineLayer.append("svg:path")
                    .attr('class', 'edge')
                    .attr('d', line.tension(0)(plist))
                    .attr('stroke', pathprops.edgeStroke || _chart.edgeStroke())
                    .attr('stroke-width', pathprops.edgeStrokeWidth || _chart.edgeStrokeWidth())
                    .attr('opacity', pathprops.edgeOpacity || 1)
                    .attr('fill', 'none');
            }
        };

        paths.forEach(_drawSpline);
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Erases any existing SVG elements and draws the diagram from scratch. `.render()`
     * must be called the first time, and `.redraw()` can be called after that.
     * @method render
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.render = function () {
        if(!_chart.initLayoutOnRedraw())
            initLayout();
        _chart.resetSvg();
        _g = _svg.append('g')
            .attr('class', 'draw');
        _edgeLayer = _g.append('g')
            .attr('class', 'edge-layer');
        _nodeLayer = _g.append('g')
            .attr('class', 'node-layer');
        _splineLayer = _g.append('g')
            .attr('class', 'spline-layer');

        if(_chart.legend())
            _chart.legend().render();
        return _chart.redraw();
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Attaches an event handler to the diagram. The currently supported events are
     * * `start()` - layout is starting
     * * `drawn(nodes, edges)` - the node and edge elements have been rendered to the screen
     * and can be modified through the passed d3 selections.
     * * `end()` - diagram layout has completed.
     * @method on
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [event] - the event to subscribe to
     * @param {Function} [f] - the event handler
     * @return {dc_graph.diagram}
     **/
    _chart.on = function(event, f) {
        _dispatch.on(event, f);
        return this;
    };

    /**
     * Returns an object with current statistics on graph layout.
     * * `nnodes` - number of nodes displayed
     * * `nedges` - number of edges displayed
     * @method getStats
     * @memberof dc_graph.diagram
     * @instance
     * @return {}
     * @return {dc_graph.diagram}
     **/
    _chart.getStats = function() {
        return _stats;
    };


    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Execute a d3 single selection in the diagram's scope using the given selector
     * and return the d3 selection. Roughly the same as
     * ```js
     * d3.select('#diagram-id').select(selector)
     * ```
     * Since this function returns a d3 selection, it is not chainable. (However, d3 selection
     * calls can be chained after it.)
     * @method select
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [selector]
     * @return {d3.selection}
     * @return {dc_graph.diagram}
     **/
    _chart.select = function (s) {
        return _chart.root().select(s);
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Selects all elements that match the d3 single selector in the diagram's scope,
     * and return the d3 selection. Roughly the same as

     * ```js
     * d3.select('#diagram-id').selectAll(selector)
     * ```

     * Since this function returns a d3 selection, it is not chainable. (However, d3 selection
     * calls can be chained after it.)
     * @method selectAll
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [selector]
     * @return {d3.selection}
     * @return {dc_graph.diagram}
     **/
    _chart.selectAll = function (s) {
        return _chart.root() ? _chart.root().selectAll(s) : null;
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Gets or sets the x scale.
     * @method x
     * @memberof dc_graph.diagram
     * @instance
     * @param {d3.scale} [scale]
     * @return {d3.scale}
     * @return {dc_graph.diagram}

     **/
    _chart.x = property(null);

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Gets or sets the y scale.
     * @method x
     * @memberof dc_graph.diagram
     * @instance
     * @param {d3.scale} [scale]
     * @return {d3.scale}
     * @return {dc_graph.diagram}

     **/
    _chart.y = property(null);

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Returns the top `svg` element for this specific chart. You can also pass in a new
     * svg element, but setting the svg element on a diagram may have unexpected consequences.
     * @method svg
     * @memberof dc_graph.diagram
     * @instance
     * @param {d3.selection} [selection]
     * @return {d3.selection}
     * @return {dc_graph.diagram}

     **/
    _chart.svg = function (_) {
        if (!arguments.length) {
            return _svg;
        }
        _svg = _;
        return _chart;
    };

    /**
     * Returns the top `g` element for this specific chart. This method is usually used to
     * retrieve the g element in order to overlay custom svg drawing
     * programatically. **Caution**: The root g element is usually generated internally, and
     * resetting it might produce unpredictable results.
     * @method g
     * @memberof dc_graph.diagram
     * @instance
     * @param {d3.selection} [selection]
     * @return {d3.selection}
     * @return {dc_graph.diagram}

     **/
    _chart.g = function (_) {
        if (!arguments.length) {
            return _g;
        }
        _g = _;
        return _chart;
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Remove the diagram's SVG elements from the dom and recreate the container SVG
     * element.
     * @method resetSvg
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.resetSvg = function () {
        _chart.select('svg').remove();
        return generateSvg();
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Causes all charts in the chart group to be redrawn.
     * @method redrawGroup
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.redrawGroup = function () {
        dc.redrawAll(chartGroup);
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Causes all charts in the chart group to be rendered.
     * @method renderGroup
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.renderGroup = function () {
        dc.renderAll(chartGroup);
    };

    /**
     * Creates an svg marker definition for drawing edge arrow tails or heads. The `viewBox` of
     * the marker is `0 -5 10 10`, so the arrow should be drawn from (0, -5) to (10, 5); it
     * will be moved and sized based on the other parameters, and rotated based on the
     * orientation of the edge.

     * (If further customization is required, it is possible to append other `svg:defs` to
     * `chart.svg()` and use refer to them by `id`.)
     * @method defineArrow
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} name - the identifier to give the marker, to be used with
     * {@link #dc_graph.diagram+edgeArrowhead edgeArrowhead} or
     * {@link #dc_graph.diagram+edgeArrowtail edgeArrowtail}
     * @param {Number} width - the width, in pixels, to draw the marker
     * @param {Number} height - the height, in pixels, to draw the marker
     * @param {Number} refX - the X reference position, in marker coordinates, which will be
     * aligned to the endpoint of the edge
     * @param {Number} refY - the Y reference position
     * @param {Function} drawf - a function to draw the marker using d3 SVG primitives, which
     * takes the marker object as its parameter.
     * @example
     * // the built-in `vee` arrow is defined like so:
     * _chart.defineArrow('vee', 12, 12, 10, 0, function(marker) {
     *   marker.append('svg:path')
     *     .attr('d', 'M0,-5 L10,0 L0,5 L3,0')
     *     .attr('stroke-width', '0px');
     * });
     * @return {dc_graph.diagram}
     **/
    _chart.defineArrow = function(name, width, height, refX, refY, drawf) {
        _arrows[name] = {
            name: name,
            width: width,
            height: height,
            refX: refX,
            refY: refY,
            drawFunction: drawf
        };
        return _chart;
    };

    _chart.addOrRemoveDef = function(id, whether, tag) {
        var data = whether ? [0] : [];
        var sel = _defs.selectAll('#' + id).data(data);

        var selEnter = sel
            .enter().append(tag)
                .attr('id', id);
        sel.exit().remove();
        return selEnter;
    };

    function edgeArrow(d, kind, name) {
        var id = _chart.arrowId(d, kind),
            markerEnter = _chart.addOrRemoveDef(id, !!name, 'svg:marker');

        if(name) {
            markerEnter
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', _arrows[name].refX)
                .attr('refY', _arrows[name].refY)
                .attr('markerUnits', 'userSpaceOnUse')
                .attr('markerWidth', _arrows[name].width*_chart.edgeArrowSize.eval(d))
                .attr('markerHeight', _arrows[name].height*_chart.edgeArrowSize.eval(d))
                .attr('stroke', _chart.edgeStroke.eval(d))
                .attr('fill', _chart.edgeStroke.eval(d))
                .call(_arrows[name].drawFunction);
        }
        return name ? id : null;
    }

    function globalTransform(pos, scale) {
        _translate = pos;
        _scale = scale;
        _g.attr('transform', 'translate(' + pos + ')' + ' scale(' + scale + ')');
    }

    function margined_bounds() {
        return {
            left: _bounds.left - _chart.margins().left,
            top: _bounds.top - _chart.margins().top,
            right: _bounds.right + _chart.margins().right,
            bottom: _bounds.bottom + _chart.margins().bottom
        };
    }

    // with thanks to comments in https://github.com/d3/d3/issues/1084
    function align_left(translate, x) {
        return translate[0] - _chart.x()(x) + _chart.x().range()[0];
    }
    function align_top(translate, y) {
        return translate[1] - _chart.y()(y) + _chart.y().range()[0];
    }
    function align_right(translate, x) {
        return translate[0] - _chart.x()(x) + _chart.x().range()[1];
    }
    function align_bottom(translate, y) {
        return translate[1] - _chart.y()(y) + _chart.y().range()[1];;
    }

    function doZoom() {
        var translate = d3.event.translate;
        if(_chart.restrictPan()) {
            var xDomain = _chart.x().domain(), yDomain = _chart.y().domain();
            var bounds = margined_bounds();
            var less1 = bounds.left < xDomain[0], less2 = bounds.right < xDomain[1],
                lessExt = (bounds.right - bounds.left) < (xDomain[1] - xDomain[0]);
            var align, nothing = 0;
            if(less1 && less2)
                if(lessExt)
                    align = 'left';
                else
                    align = 'right';
            else if(!less1 && !less2)
                if(lessExt)
                    align = 'right';
                else
                    align = 'left';
            switch(align) {
            case 'left':
                translate[0] = align_left(translate, bounds.left);
                break;
            case 'right':
                translate[0] = align_right(translate, bounds.right);
                break;
            default:
                ++nothing;
            }
            less1 = bounds.top < yDomain[0]; less2 = bounds.bottom < yDomain[1];
            lessExt = (bounds.bottom - bounds.top) < (yDomain[1] - yDomain[0]);
            if(less1 && less2)
                if(lessExt)
                    align = 'top';
                else
                    align = 'bottom';
            else if(!less1 && !less2)
                if(lessExt)
                    align = 'bottom';
                else
                    align = 'top';
            switch(align) {
            case 'top':
                translate[1] = align_top(translate, bounds.top);
                break;
            case 'bottom':
                translate[1] = align_bottom(translate, bounds.bottom);
                break;
            default:
                ++nothing;
            }

            if(nothing<2)
                _zoom.translate(translate);
        }
        globalTransform(translate, d3.event.scale);
    }

    function resizeSvg(w, h) {
        if(_svg) {
            _svg.attr('width', w || _chart.width())
                .attr('height', h || _chart.height());
        }
    }

    function enableZoom() {
        _svg.call(_zoom);
        _svg.on('dblclick.zoom', null);
    }
    function disableZoom() {
        _svg.on('.zoom', null);
    }

    function generateSvg() {
        _svg = _chart.root().append('svg');
        resizeSvg();

        _defs = _svg.append('svg:defs');

        // start out with 1:1 zoom
        if(!_chart.x())
            _chart.x(d3.scale.linear()
                     .domain([0, _chart.width()])
                     .range([0, _chart.width()]));
        if(!_chart.y())
            _chart.y(d3.scale.linear()
                     .domain([0, _chart.height()])
                     .range([0, _chart.height()]));
        _zoom = d3.behavior.zoom()
            .on('zoom', doZoom)
            .x(_chart.x()).y(_chart.y());
        if(_chart.mouseZoomable()) {
            if(_chart.altKeyZoom()) {
                d3.select(document)
                    .on('keydown', function() {
                        if(d3.event.key === 'Alt')
                            enableZoom();
                    })
                    .on('keyup', function() {
                        if(d3.event.key === 'Alt')
                            disableZoom();
                    });
            }
            else enableZoom();
        }

        return _svg;
    }

    _chart.invertCoord = function(clientCoord) {
        return [
            _chart.x().invert(clientCoord[0]),
            _chart.y().invert(clientCoord[1])
        ];
    };

    _chart.defineArrow('vee', 12, 12, 10, 0, function(marker) {
        marker.append('svg:path')
            .attr('d', 'M0,-5 L10,0 L0,5 L3,0')
            .attr('stroke-width', '0px');
    });
    _chart.defineArrow('dot', 7, 7, 0, 0, function(marker) {
        marker.append('svg:circle')
            .attr('r', 5)
            .attr('cx', 5)
            .attr('cy', 0)
            .attr('stroke-width', '0px');
    });

    /**
     * Set the root SVGElement to either be any valid [d3 single
     * selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying a dom
     * block element such as a div; or a dom element or d3 selection. This class is called
     * internally on chart initialization, but be called again to relocate the chart. However, it
     * will orphan any previously created SVGElements.
     * @method anchor
     * @memberof dc_graph.diagram
     * @instance
     * @param {anchorSelector|anchorNode|d3.selection} [parent]
     * @param {String} [chartGroup]
     * @return {String|node|d3.selection}
     * @return {dc_graph.diagram}
     */
    _chart.anchor = function(parent, chartGroup) {
        if (!arguments.length) {
            return _anchor;
        }
        if (parent) {
            if (parent.select && parent.classed) { // detect d3 selection
                _anchor = parent.node();
            } else {
                _anchor = parent;
            }
            _chart.root(d3.select(_anchor));
            _chart.root().classed(dc_graph.constants.CHART_CLASS, true);
            dc.registerChart(_chart, chartGroup);
        } else {
            throw new dc.errors.BadArgumentException('parent must be defined');
        }
        _chartGroup = chartGroup;
        return _chart;
    };

    /**
     * Returns the internal numeric ID of the chart.
     * @method chartID
     * @memberof dc.baseMixin
     * @instance
     * @returns {String}
     */
    _chart.chartID = function () {
        return _chart.__dcFlag__;
    };

    /**
     * Returns the DOM id for the chart's anchored location.
     * @method anchorName
     * @memberof dc_graph.diagram
     * @instance
     * @return {String}
     */
    _chart.anchorName = function () {
        var a = _chart.anchor();
        if (a && a.id) {
            return a.id;
        }
        if (a && a.replace) {
            return a.replace('#', '');
        }
        return 'dc-graph' + _chart.chartID();
    };

    return _chart.anchor(parent, chartGroup);
};
